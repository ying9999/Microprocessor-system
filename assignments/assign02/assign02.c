#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <inttypes.h>
#include "pico/stdlib.h"
#include "pico/float.h"         // Required for using single-precision variables.
#include "pico/double.h"        // Required for using double-precision variables.
#include "pico/multicore.h"     // Required for using multiple cores on the RP2040.
#include "hardware/pio.h"       // Required for using hardware
#include "ws2812.pio.h"         // Required for setting up pio for pico
#include "hardware/clocks.h"    // Required for using clocks. (might be used)
#include "hardware/watchdog.h"

// Declare the main assembly code entry point.
void main_asm();

#define RED 0               // Color number of RED
#define GREEN 1             // Color number of GREEN
#define BLUE 2              // Color number of BLUE
#define YELLOW 3            // Color number of YELLOW
#define WHITE 4             // Color number of WHITE
#define MAP_SIZE 36         // The size of char-morse map

#define IS_RGBW true        // Will use RGBW format
#define NUM_PIXELS 1        // There is 1 WS2812 device in the chain
#define WS2812_PIN 28       // The GPIO pin that the WS2812 connected to

int curLevel, lives, checkMode, correctCounter;
char input[200];            // user input array
char randomChar;            // create a global variable for the randomized characters to be displayed as question          
int inputIndex = 0;         // index of user input array
int initializePIO;          // create a variable to control the initialization when setting up the LED
int totalCorrect = 0;       // counts the number of total correct answers
int totalWrong = 0;         // counts the number of total incorrect answers


struct codeMap {
    char character;
    char* morse;
};

struct codeMap* morseMap;

// Print the message that asks the user to choose the difficulty level
void printChooseLevel()
{
        printf("\n\n                             Please choose a level :                   ");
        printf("\n\n                                1 (.----) --- level 1                           ");
        printf("\n\n                                2 (..--)  --- level 2                           \n\n                                   ");

}


/**
 * @brief Function to generate an unsigned 32-bit composit GRB
 *        value by combining the individual 8-bit paramaters for
 *        red, green and blue together in the right order.
 * 
 * @param r     The 8-bit intensity value for the red component
 * @param g     The 8-bit intensity value for the green component
 * @param b     The 8-bit intensity value for the blue component
 * @return uint32_t Returns the resulting composit 32-bit RGB value
 */
static inline uint32_t urgb_u32(uint8_t r, uint8_t g, uint8_t b) 
{
    return  ((uint32_t) (r) << 8)  |
            ((uint32_t) (g) << 16) |
            (uint32_t) (b);
}

/**
 * @brief Wrapper function used to call the underlying PIO
 *        function that pushes the 32-bit RGB colour value
 *        out to the LED serially using the PIO0 block. The
 *        function does not return until all of the data has
 *        been written out.
 * 
 * @param pixel_grb The 32-bit colour value generated by urgb_u32()
 */
static inline void put_pixel(uint32_t pixel_grb) 
{
    pio_sm_put_blocking(pio0, 0, pixel_grb << 8u);
}


// Set LED color according to the input variable of color number
void setLEDColor(int color_no){

    if(initializePIO == 0)
    {
        PIO pio = pio0;
        uint offset = pio_add_program(pio, &ws2812_program);
        ws2812_program_init(pio, 0, offset, WS2812_PIN, 800000, IS_RGBW);
        initializePIO = 1;
    }

    switch (color_no)
    {
    case RED:
        // Set the color to red at half intensity
        put_pixel(urgb_u32(0x7F,0,0));
        break;
    case GREEN:
        // Set the color to green at half intensity
        put_pixel(urgb_u32(0,0x7F,0));
        break;
    case BLUE:
        // Set the color to blue at half intensity
        put_pixel(urgb_u32(0,0,0x7F));
        break;
    case YELLOW:
        // Set the color to yellow at half intensity
        put_pixel(urgb_u32(0x5F,0x3F,0));
        break;
    case WHITE:
        // Set the color to white at half intensity
        put_pixel(urgb_u32(0x3F,0X3F,0x3F));
        break;
    default:
        break;
    }
}


// Turn input characters into morse for level 1 players
//      Display the morse code string in the user interface if in level 1
//      Return te morse code string
char * charToMorse(){
    for(int i = 0; i < MAP_SIZE; i++){
        if(morseMap[i].character == randomChar){
            return morseMap[i].morse;
        }
    }
    printf("Invalid character!");
    return NULL;
}
/*
char * charToMorse(char random_char){
    for(int i = 0; i < MAP_SIZE; i++){
        if(morseMap[i].character == random_char){
            printf(morseMap[i].morse);
            return morseMap[i].morse;
        }
    }
    printf("Invalid character!");
*/   


// Print the equivalent alphanumeric character according to the input morse code sequence
void morseToChar(char* morseSeq){
    for(int i = 0; i < MAP_SIZE; i++){
        if(strcmp(morseMap[i].morse, morseSeq) == 0){
            printf("\n%c \n", morseMap[i].character);
            return;
        }
    }
    printf("? (Invalid character)");
}



// // Check correctness
// //      Take in user_input and the correct morse code both as strings and compare them
// //      If different, update the global variable lives
// //      Update the correct_counter and return the updated variable
// int checkCorrectness(int correct_counter, char * user_input, char correct_code){
//     // get the morse code of the correct character the user should have entered.
//     char* correct_morse = charToMorse(correct_code);
//     // compare the user input morse code and the correct morse code
//     int strcmp (const char* user_input, const char* correct_morse);
//     // if 0 then they are the same therefore increment the correct_counter
//     if (strcmp == 0){
//         return correct_counter + 1;
//     // else return the precious correct_counter
//     } else {
//         return correct_counter;
//     }
// }



// Decode the button input into dash or dot
void Dash_Dot(int time)
{
   if(time < 250000)             //if time < 250000, it a dot
   {
     input[inputIndex] = '.';         // add '.' to the input array
     printf(".");
     inputIndex++;                   // index + 1
   }
   else
   {
     input[inputIndex] = '-';        //if time >= 250000, it a dash
     printf("-");               // add '-' to the input array
     inputIndex++;                   // index+ 1
   }
}




// This function combined the functionalities of difficulty level selecting and correctness checking.
// When checkMode is 0, we use this function to handle level selecting
// If levelCode = 11 -> choose Difficulty level again
// If levelCode = 12 -> branch to level1
// If levelCode = 13 -> branch to level2

// When checkMode is 1, we use this function to handle correctness checking
// If levelCode = 2 -> skip the checking process once as no user input detected
// If levelCode = 1 -> input is correct
// If levelCode = 0 -> input is not correct
int check()
{
    int levelCode;                                    
    if(checkMode == 0)                               // use number to switch between choose Difficulty level (number = 0 -> Difficulty level)
   {                                             //  and check Correctness (number = 1 -> check Correctness)
    levelCode = 11; 
    input[inputIndex] = '\0';                         // add the null character at the end of the string

    if(strcmp(input, morseMap[27].morse) == 0)   // if you enter 1 
    {
      levelCode = 12;                                // you choose level1
    }

    if(strcmp(input, morseMap[28].morse) == 0)   // if you enter 1 
    {
      levelCode = 13;                                // you choose level1
    }

    if(levelCode == 13 || levelCode == 12)               // switch to check Correctness after choosing difficulty level
    {
        setLEDColor(GREEN);
        checkMode = 1;
    }
   }
   else
   {
       if(strcmp(input[0], "") == 0)
       {
           levelCode = 2;
           return levelCode;
       }
       input[inputIndex] = '\0';                    // add the null character at the end of the string
       morseToChar(input);
       char * answer = charToMorse(randomChar);       
       if(strcmp(input, answer) == 0)         // compare the string you enterd with the corresponding morse code of the question character
       {
           levelCode = 1;                          // if correct, return levelCode = 1
           setLEDColor(WHITE);                     // set LED color to white
       }
       else
       {  
           levelCode = 0;                          // if not correct, return levelCode = 0
           setLEDColor(YELLOW);                    // set LED color to yellow
       }
   }
    
    inputIndex = 0;                                 // reset the index
    strcpy(input, "");                         // reset the user input array
    return levelCode; 
}


// Print level 1 message
void level1Message()
{
    printf("\n\nCurrently at level 1.");
    curLevel = 1;

}


// Print level 2 message
void level2Message()
{
    printf("\n\nCurrently at level 2.");
    curLevel = 2;
}


// Print the result of the correctness checking and the current correct counter
void checkMessage(int a)
{
    if(a == 1)
    {
        printf("\n\n\nCorrect! \n\n");
    }
    else
    {
        printf("\n\n\nWrong! \n\n");
    }
}




void generateMap(){
    morseMap = malloc(sizeof(struct codeMap) * MAP_SIZE);
    morseMap[0].character = 'A';
    morseMap[1].character = 'B';
    morseMap[2].character = 'C';
    morseMap[3].character = 'D';
    morseMap[4].character = 'E';
    morseMap[5].character = 'F';
    morseMap[6].character = 'G';
    morseMap[7].character = 'H';
    morseMap[8].character = 'I';
    morseMap[9].character = 'J';
    morseMap[10].character = 'K';
    morseMap[11].character = 'L';
    morseMap[12].character = 'M';
    morseMap[13].character = 'N';
    morseMap[14].character = 'O';
    morseMap[15].character = 'P';
    morseMap[16].character = 'Q';
    morseMap[17].character = 'R';
    morseMap[18].character = 'S';
    morseMap[19].character = 'T';
    morseMap[20].character = 'U';
    morseMap[21].character = 'V';
    morseMap[22].character = 'W';
    morseMap[23].character = 'X';
    morseMap[24].character = 'Y';
    morseMap[25].character = 'Z';
    morseMap[26].character = '0';
    morseMap[27].character = '1';
    morseMap[28].character = '2';
    morseMap[29].character = '3';
    morseMap[30].character = '4';
    morseMap[31].character = '5';
    morseMap[32].character = '6';
    morseMap[33].character = '7';
    morseMap[34].character = '8';
    morseMap[35].character = '9';

    morseMap[0].morse = ".-";
    morseMap[1].morse = "-...";
    morseMap[2].morse = "-.-.";
    morseMap[3].morse = "-..";
    morseMap[4].morse = ".";
    morseMap[5].morse = "..-.";
    morseMap[6].morse = "--.";
    morseMap[7].morse = "....";
    morseMap[8].morse = "..";
    morseMap[9].morse = ".---";
    morseMap[10].morse = "-.-";
    morseMap[11].morse = ".-..";
    morseMap[12].morse = "--";
    morseMap[13].morse = "-.";
    morseMap[14].morse = "---";
    morseMap[15].morse = ".--.";
    morseMap[16].morse = "--.-";
    morseMap[17].morse = ".-.";
    morseMap[18].morse = "...";
    morseMap[19].morse = "-";
    morseMap[20].morse = "..-";
    morseMap[21].morse = "...-";
    morseMap[22].morse = ".--";
    morseMap[23].morse = "-..-";
    morseMap[24].morse = "-.--";
    morseMap[25].morse = "--..";
    morseMap[26].morse = "-----";
    morseMap[27].morse = ".----";
    morseMap[28].morse = "..--";
    morseMap[29].morse = "...--";
    morseMap[30].morse = "...-";
    morseMap[31].morse = ".....";
    morseMap[32].morse = "-....";
    morseMap[33].morse = "--...";
    morseMap[34].morse = "---..";
    morseMap[35].morse = "----.";
}

// Function to enable watchdog timer
void enable_timer(){
    watchdog_enable(10000, 1);
}


// Function to update watchdog timer
void update_timer(){
    watchdog_update();
}

// // Check level and returns the new level number
// //      If correct 5 times in a row then update the level
// int checkLevel(int correct_counter){
//     if (correct_counter == 5){
//         curLevel += 1;
//     }
//     return curLevel;
// }


// Check the current user lives
//      If reaches zero, returns 0 to print game-over message.
//      If does not reach zero, return 1 to continue game.
int checkLives() {
    if (lives == 0) {
        setLEDColor(RED);
        return 0;
    }
    else{
        return 1;
    }
}


// Update the current user lives
//      If input incorrect, decrease the user lives by one
//      If inout correct and current lives is under 3, increase the user lives by one.
void updateInfo(int correctness) {
     if(correctness == 0) {
        lives--;
        totalWrong++;
        correctCounter = 0;
     }
     else if(correctness == 1) {
        if(lives != 3) {
            lives++;
        }
        correctCounter++;
        totalCorrect++;
     }
     printf("Current lives: %d.\n", lives);
     printf("Current correct counter (in a row): %d.\n", correctCounter);
}


// // Update the current correct counter
// //      If input incorrect, set the correct counter back to zero.
// //      If inout correct, increase the correct counter by one.
// //      Display the current correct counter.
// void updateCorrectCounter(int correctness) {
//      if(correctness == 0) {
//         correctCounter = 0;
//      }
//      else if(correctness == 1) {
//         correctCounter++;
//      }
// }

// Check the correct counter to see if requires level-up
//      If at level 1 and the user has entered correctly 5 times in a row, set current level number to 2 and return 0
//      If updated from level 1 to level 2 and the user has entered correctly 10 times in a row, return 1 for congrats message
//      If started from level 2 and the user has entered correctly 5 times in a row, return 1 for congrats message
//      If not yet to level-up, return 0
int checkCorrectCounter() {
    update_timer();
    if(curLevel==1 && correctCounter==5) {
       curLevel = 2;
       printf("\nLevel Up! \n");
       return 2;
    }
    if(curLevel==2 && correctCounter==5) {
       return 1;
    }
    if(curLevel==2 && correctCounter==10) {
       return 1;
    }
    return 0;
}


// Game complete message
//      If the player loses all 3 lives, print "Game over"
//      If the player passed all the rounds, print "You win"
void gameComplete(){
    if(lives == 0) {
        printf("\nGame over!\n");
    }
    else {
        printf("\nCongratulations! You win!\n");
    }
    double accuracy = (double) totalCorrect / (totalWrong + totalCorrect) * 100;
    printf("\nNumber of correct answer: %d", totalCorrect);
    printf("\nNumber of incorrect answer: %d", totalWrong);
    printf("\nAccuracy: %.2f%%\n\n", accuracy);
    watchdog_reboot(0, 0, 3000);
}


// Generate a randomized character to be displayed as question
void displayQuestion(int lv){
    // Generate a random character from the below string.
    randomChar = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[random () % 36];

    if (lv == 1) {
        // return the question string using the randomChar and the morse code translation of that character.
        printf("\nPlease enter the morse code for character %c (", randomChar);
        char * morse = charToMorse(randomChar);  
        printf("%s )\n", morse);
    } else {
        // return the question string using the randomChar only.
        printf("\nPlease enter the morse code for character %c : \n", randomChar);
    }
}
/*
char * displayQuestion(int lv){
    // Generate a random character from the below string.
    char randomChar = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"[random () % 36];
    if (lv == 1) {
        // return the question string using the randomChar and the morse code translation of that character.
        char* question = strncat("Please enter the morse code for character \"", &randomChar, 1);
        char* question = strncat(question, &"\" (", 1);
        char* question = strncat(question, &charToMorse(randomChar), 1);
        char* question = strncat(question, &"): ", 1);
        return question;
    } else {
        // return the question string using the randomChar only.
        char* question = strncat("Please enter the morse code for character \"", &randomChar, 1);
        char* question = strncat(question, &"\": ", 1);
        return question;
    }

}*/



/* Choose difficulty levels
//      Print request to user interface and take in user input as the selected level number
void chooseLevel(){
    int lv, quit;
	while(!quit){
    	printf("\n\n\n\n                          Please choose a level :                   ");
        printf("\n\n                                1 --- level 1                           ");
        printf("\n\n                                2 --- level 2                           ");
    	scanf("%d", &lv);
    	if(lv == 1 || lv == 2){
			level = lv;
			quit = 1;
		}
		else{
			printf("\n\nPlease enter a valid number!\n");
		}
	}
}*/

// Print welcome message
void welcomeMessage()
{
    printf("\n################################################################################\n");
    printf("\n                             Welcome to the game!                               \n\n");
    printf("\n     Group 29                                                                   \n\n\n");
    printf("\n                       Rule : Press the button to input Morse Code. If    ");
    printf("\n                              you enters the correct Morse code sequence, ");
    printf("\n                              you will gain a life. Otherwise, you will   ");
    printf("\n                              lose a life. If the number of your lifes    ");
    printf("\n                              reaches zero, then the game is over.        ");
    printf("\n\n\n\n################################################################################\n\n\n\n");
}

// Game setup
//      Let user choose the difficulty level
//      Initialize LED color to blue using setLEDColor() function
//      Initialize the global variable lives to 3
void setup(){
    welcomeMessage();
    setLEDColor(BLUE);
    generateMap();
    lives = 3;
}

// Initialise a GPIO pin – see SDK for detail on gpio_init()
void asm_gpio_init(uint pin) {
    gpio_init(pin);
}

// Set direction of a GPIO pin – see SDK for detail on gpio_set_dir()
void asm_gpio_set_dir(uint pin, bool out) {
    gpio_set_dir(pin, out);
}

// Get the value of a GPIO pin – see SDK for detail on gpio_get()
bool asm_gpio_get(uint pin) {
    return gpio_get(pin);
}

// Set the value of a GPIO pin – see SDK for detail on gpio_put()
void asm_gpio_put(uint pin, bool value) {
    gpio_put(pin, value);
}

// Enable falling-edge interrupt – see SDK for detail on gpio_set_irq_enabled()
void asm_gpio_set_irqF(uint pin) {
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_FALL, true);
}

// Enable rising-edge interrupt – see SDK for detail on gpio_set_irq_enabled()
void asm_gpio_set_irqR(uint pin) {
    gpio_set_irq_enabled(pin, GPIO_IRQ_EDGE_RISE, true);
}


// Main entry point of the application

// The game runs in a while loop, exit the loop if the player loses all 3 lives or wins the game
// Once exit the loop, print game complete message with gameComplete() function
int main() 
{
    stdio_init_all();              // Initialise all basic IO
    if (watchdog_caused_reboot()) {
        printf("\nGame restart.\n\n");
    } 
    main_asm();                    // Jump into the ASM code
    return 0;                        // Application return code
}